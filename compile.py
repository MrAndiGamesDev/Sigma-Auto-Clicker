#!/usr/bin/env python3
import os
import argparse
import sys

def parse_args():
    parser = argparse.ArgumentParser(
        description="Combine all .py files under a folder into a single Python script."
    )
    parser.add_argument(
        "-i", "--input-folder", default=".",
        help="Root folder to search for .py files (e.g. cloned repo 'Sigma-Auto-Clicker/dev')"
    )
    parser.add_argument(
        "-o", "--output-file", default="combined_sigma_autoclicker.py",
        help="Filename for the combined output Python script"
    )
    parser.add_argument(
        "-e", "--exclude-files", nargs="*", default=[
            "test.py",
            "setup_venv_and_install_packages.py",
            "updatepypackages.py",
            "combine_sigma.py",
        ],
        help="Base-names of .py files to exclude"
    )
    parser.add_argument(
        "-E", "--exclude-folders", nargs="*", default=[
            ".git",
            "docs",
            "tests",
            "__pycache__",
            "build",
            "dist",
            "src/Packages/CustomLogging",  # known extra package folder
        ],
        help="Folder names to exclude"
    )
    parser.add_argument(
        "--only-one-main", action="store_true",
        help="Keep only first __main__ block; comment out others"
    )
    parser.add_argument(
        "--verbose", action="store_true",
        help="Verbose output"
    )
    return parser.parse_args()

def find_py_files(root, exclude_files, exclude_folders, verbose=False):
    py_files = []
    exclude_folders_set = set(exclude_folders)
    for dirpath, dirnames, filenames in os.walk(root):
        # Remove excluded folders from walk
        dirnames[:] = [d for d in dirnames if d not in exclude_folders_set]
        for fname in filenames:
            if not fname.endswith(".py"):
                continue
            if fname in exclude_files:
                if verbose:
                    print(f"Skipping excluded file: {fname}")
                continue
            full_path = os.path.join(dirpath, fname)
            rel_path = os.path.relpath(full_path, root)
            py_files.append((rel_path, full_path))
    py_files.sort(key=lambda x: x[0])
    return py_files

def combine_files(args):
    py_files = find_py_files(
        args.input_folder,
        exclude_files=[args.output_file] + args.exclude_files,
        exclude_folders=args.exclude_folders,
        verbose=args.verbose,
    )

    if args.verbose:
        print(f"Found {len(py_files)} .py files to include:")
        for rel, _ in py_files:
            print("  ", rel)

    main_seen = False

    with open(args.output_file, "w", encoding="utf-8") as outf:
        outf.write("# Combined Python Script\n")
        outf.write(f"# Source folder: {args.input_folder}\n")
        outf.write(f"# Generated by: {os.path.basename(__file__)}\n\n")

        for rel, full in py_files:
            outf.write(f"# {'='*20} BEGIN: {rel} {'='*20}\n")
            try:
                with open(full, "r", encoding="utf-8") as inf:
                    content = inf.read()
            except Exception as e:
                print(f"Error reading {full}: {e}", file=sys.stderr)
                continue

            if args.only_one_main and "__name__" in content and "__main__" in content:
                if main_seen:
                    if args.verbose:
                        print(f"Commenting out __main__ block in {rel}")
                    lines = content.splitlines()
                    new_lines = []
                    in_main = False
                    for line in lines:
                        if not in_main:
                            new_lines.append(line)
                            if line.strip().startswith("if __name__") and "__main__" in line:
                                in_main = True
                                new_lines.append("#   [MAIN BLOCK COMMENTED OUT]")
                        else:
                            new_lines.append("# " + line)
                    content = "\n".join(new_lines)
                else:
                    main_seen = True
                    if args.verbose:
                        print(f"Keeping __main__ block in {rel}")

            outf.write(content.rstrip() + "\n")
            outf.write(f"# {'='*20} END: {rel} {'='*21}\n\n")

    print(f"\nâœ… Combined {len(py_files)} files into '{args.output_file}'")

def main():
    args = parse_args()
    combine_files(args)

if __name__ == "__main__":
    main()